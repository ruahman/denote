---
title:      "nix"
date:       2024-11-20T09:23:51-04:00
tags:       []
identifier: "20241120T092351"
signature:  ""
---

Nix from first principles

https://tonyfinn.com/blog/nix-from-first-principles-flake-edition/

setup nix
``` shell
sh <(curl -L https://nixos.org/nix/install) --daemon

```

The default on Linux and MacOS is to do what's called a multi-user install, where Nix packages are available to all users. 


To enable these flakes, edit /etc/nix/nix.conf and add/modify the following line:

The multi-user install creates a directory /nix, which all packages are installed into. 

``` ini
experimental-features = nix-command flakes

```

# Nix Package Manager CLI 

The foundational part of Nix is the Nix package manager. 
This is a tool that allows you to install packages.

To install your first package, run the nix profile install command. 

`nix profile install nixpkgs#ripgrep`

install multiple packages 

`nix profile install nixpkgs#fzf nixpkgs#jq`

By default, nix profile will set itself up in your ~/.nix-profile directory.

to list what you installed
` nix profile list`

to update a specific package
`nix profile upgrade <pkg reference>`

show the history of your profile
`nix profile history`

roleback your profile
`nix profile rollback`

go back forward
`nix profile rollback --to 2`

garbage collect.
This will delete packages that are only used by profiles or generations that have been deleted.
`nix store gc`

# Nixlang

to start experimenting
`nix repl`

 since the language was designed for package management, it also has some first class data types that other languages do not. The most common of these is the path.

 ```shell 
 nix-repl> ./README.md
/home/tony/code/nix-guide/README.md
 ```

sets

``` shell
nix-repl> { a = 1; b = 2; }
```

 functions are written as a argument: expression and called by using the function name and a space.

 ``` shell
 nix-repl> x = arg: { foo = arg; }

nix-repl> x 123
{ foo = 123; }
 ```

You can use destructuring to extract fields from sets as arguments. 

``` shell
nix-repl> x = { foo, bar }: {a = foo; b = bar; }

nix-repl> x { foo = 1; bar = 2; }
{ a = 1; b = 2; }
```

But what if you want multiple positional arguments? Similar to languages like Haskell, functions use what is known as currying to handle multiple arguments. This means that any function which take multiple arguments is actually represented as functions which take a single argument and return another function. 

``` nix
adder = amountToAdd: x: amountToAdd + x
```

- This is effectively a function which takes an argument amountToAdd, then returns the function x: amountToAdd + x


 what if you have some value you want to use multiple times?
 In that case you can use a let expression to create what is called a binding.
 
 ``` nix
 # "abcabc"
let x = "abc"; in x + x;

# "abcxyz"
let x = "abc"; y = "xyz"; in x + y; 
 ```
-  The values are only available for the single expression after the let keyword.

 the with expression takes all the fields of a set and makes them available as bindings within the expression following the with.
 `with <some-set>; <expression>`
 
 ``` nix
 let longNameSet = {
    foo = 1;
    bar = 2;
}; in ( # Brackets optional, added for clarity
    with longNameSet; {
        sum = foo + bar;
    }
)
 ```

inherit is used to copy values from an outer scope into a set being constructed.

``` nix
let someVariableWithALongName = 5; in {
    inherit someVariableWithALongName;
}
```

is the same as this

``` nix
let someVariableWithALongName = 5; in {
    someVariableWithALongName = someVariableWithALongName;
}
```

# derivations

A Nix derivation is a special type of set created from the derivation function which describes how to obtain and build a package. 
- a special set used to obtain and build a package

The Nix package manger will then evaluate this derivation, and use the result to copy the built package into the Nix store

The subfolders are hashes derived from the inputs to the expression that built the stored packages.

 
 derivation itself takes a set as its argument, which it will expand out into the full derivation when evaluted.
 
 system: x86_64-linux or aarch64-darwin
 name: s a string which gives the package a name
 builder:  is a program that is run to build the derivation.
 

a nix expression which defines the derivation 
``` nix
derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    # Replace with x86_64-darwin, aarch64-darwin or aarch64-linux if needed
    system = "x86_64-linux";
}
```
- you can run `nix build` 


You run the nix build command. 

 The derivation is built in an isolated environment, and since you haven't included anything in that environment, you get a bourne compatible shell and not much else. Since cp is not a shell builtin [1], you'll need to provide the command.

Bootstrapping

include cp for builder
``` nix
derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    # busybox_CP will be copied to the nix store, and the path 
    # will be put in the $cp env variable.
    cp = ./busybox_CP; 
}
```

download cp and chmod

``` nix
let 
  fetchurl = import <nix/fetchurl.nix>;
in derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    cp = fetchurl {
      # Download from the busybox server
      url = "https://www.busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox_CP";
      # Check the downloaded file against the hash so Nix knows if the build is not reproducing
      # Download the file once and use `nix hash to-base32 $(nix hash path busybox_CP)`
      # to find the value to put here
      sha256 = "0mq1487x7aaz89211wrc810k9d51nsfi7jwfy56lg3p20m54r22a";
      # Have Nix make the file executable on download
      executable = true; 
    };
    chmod = fetchurl {
      url = "https://www.busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox_CHMOD";
      sha256 = "06fp9hqf0cxjqvs9hjg5n81lm5yhkp6iwiaa74j4cfg0wbf7d8fc";
      executable = true;
    };
}
```

# Nixpkgs

the default execution environment is incredibly barebones, to the point that you needed to include such fundamental tools as chmod and cp

If that process had to be repeated by every Nix user, it would be very inconvenient. Luckily, there is nixpkgs, which provides a number of packages that the community has already built

 stdenv.mkDerivation. This is a function that is an enhanced version of the built in derivation.
 
 It does the bootstrapping for you ensuring you have a decent minimal environment to build on. 
 
 It provides an easy way to add extra dependencies to your specific derivation and includes them in the path so you don't have to use the $cp, $chmod variables in the scripts like was required last time.
 
 It provides a default builder which runs in bash and does a ./configure && make installation, with some variables that lets you override parts of it without having to write a whole new script
 
 ``` nix
 let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/0b20bf89e0035b6d62ad58f9db8fdbc99c2b01e8.tar.gz") {};
in pkgs.stdenv.mkDerivation {
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    dontUnpack = true;
    installPhase = ''
    cp $src $out
    chmod +x $out
    '';
}
 ```
 
There's no builder provided - in this example the standard builder provided by the stdenv is used, with one phase that is overridden from the .nix file.

The installPhase option is what overrides this one phase. 


The dontUnpack attribute also tells the builder not to try unpack the source. Since most software sources have more than one file, the standard builder defaults to treating the src as an archive and trying to unpack it. Here the src is just a shell script, so that unpacking is not required.
- source is not an archive so you don't need to unpack it. 
 
use the package to build
 ``` nix
 let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/0b20bf89e0035b6d62ad58f9db8fdbc99c2b01e8.tar.gz") {};
in pkgs.stdenv.mkDerivation {
    src = ./rust-hello;
    name = "rust-hello-1.0";
    system = "x86_64-linux";
    nativeBuildInputs = [ pkgs.cargo ];
    buildPhase = ''
      cargo build --release
    '';
    installPhase = ''
      mkdir -p $out/bin
      cp target/release/rust-hello $out/bin/rust-hello
      chmod +x $out
    '';
}
 ```
 
# flakes

a new standard format for nix projects to declare all their outputs

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-22.05";

  outputs = {
    self,
    nixpkgs,
  }: let
    system = "x86_64-linux";
    pkgs = import nixpkgs {inherit system;};
  in {
    packages.${system}.default =
      pkgs.stdenv.mkDerivation
      {
        src = ./rust-hello;
        name = "rust-hello-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build --release
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/release/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
  };
}
```

The flake.nix file defines a Nix attribute set, with two top level attributes. 

The first of these is inputs, which defines all the dependencies this flake will import from. 

The second top level attribute is outputs, which is defined as a function returning an attribute set. 

It receives two arguments, self, which is the flake iself so you can refer to other outputs without resorting to rec,
and nixpkgs, which is the input the flake defined in the inputs attribute set. 

When the function is called, it gets the pkgs object by importing the nixpkgs expression. Inside flakes you also need to tell it which system to build nixpkgs for, so the flake passes it the x86_64-linux system field. 

This example flake defines a single output: packages.x86_64-linux.default.

A flake can have multiple packages defined in the one flake. 

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-22.05";

  outputs = {
    self,
    nixpkgs,
  }: let
    system = "x86_64-linux";
    pkgs = import nixpkgs {inherit system;};
  in {
    # The default package is the same as before
    packages.${system} = {
      default = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build --release
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/release/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
      # Now there's a new package
      debug = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-debug-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/debug/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
    };
  };
}
```

As before, it's still possible to build the release package with a nix build. The newly added debug package can be built with nix build .#debug.

# Developer Environments

While packages are the most common type of item you'll find contained in flakes, another type of item is a *development shell*.

This is an environment that you can enter with the `nix develop` command

 By running just nix develop without specifying which shell is wanted, nix will put you in a bash shell with the environment from the default package.

However, sometimes you may wish to set up additional tools in a development environment, for example you may have scripts written in Python and want to have Python available as for a developer to use, yet you do not want to include Python as a dependency in your built package. 

You can customise the nix develop environment with the devShells attribute set in a flake. 

The helper function pkgs.mkShell is useful here.
This is an extended version of the mkDerivation function that has been used in previous examples, except this version is specialised for shells.

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
    in
    {
      devShells.x86_64-linux.default = pkgs.mkShell {
        packages = [
          # Made available on the CLI
          pkgs.cargo
          pkgs.rustc
          pkgs.python3
        ];
        RUST_LOG = 1; # Set as environment variable
      };

      # You could also define extra shells or packages here
    };
}
```
- Now if you run `nix develop` in the same directory as this flake, you'll be left at a bash shell with cargo, python3 and rustc available.


You could even define multiple shells. 

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
      # A list of shell names and their Python versions
      pythonVersions = {
        python38 = pkgs.python38;
        python39 = pkgs.python39;
        python310 = pkgs.python310;
        default = pkgs.python310;
      };
      # A function to make a shell with a python version
      makePythonShell = shellName: pythonPackage: pkgs.mkShell {
        # You could add extra packages you need here too
        packages = [ pythonPackage ]; 
        # You can also add commands that run on shell startup with shellHook
        shellHook = ''
          echo "Now entering ${shellName} environment."
        '';
      };
    in
    {
      # mapAttrs runs the given function (makePythonShell) against every value
      # in the attribute set (pythonVersions) and returns a new set
      devShells.x86_64-linux = builtins.mapAttrs makePythonShell pythonVersions;
    };
}
```
- Now if you run the command nix develop .#python38, you will end up in a shell that contains Python 3.8,

You can also inspect all items that are available in the flake with the command nix flake show:


if you want to use another shell like zsh or fish
``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
    in
    {
      devShells.x86_64-linux.default = pkgs.mkShell {
        packages = [
          pkgs.fish
        ];
        # Note that `shellHook` still uses bash syntax.
        # This starts fish, then exists the bash shell when fish exits.
        shellHook = ''
          fish && exit
        '';
      };
    };
}
```

# Runnable Flakes

In the last two parts, I covered using flakes for two different types of output: packages and developer environments.

This time I'll cover a third type of output - runnable commands.


specify name of program to run if when run `nix run .#debug`
``` nix
# Rest of flake omitted
{
    debug = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-debug-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        meta.mainProgram = "rust-hello";
        buildPhase = ''
            cargo build
        '';
        installPhase = ''
            mkdir -p $out/bin
            cp target/debug/rust-hello $out/bin/rust-hello
            chmod +x $out
        '';
    };
}
```


meta.mainProgram is a great option when you have a package to run which is named differently to its binary, but in some situations you may want even more control over what happens. For example, you might want to add a run configuration to run a static web server for dev purposes.

To add a run configuration not tied to a built package, you can use the apps key of a flake. 
This takes two keys, type, and program.
type must be set to app 
program is set to the path to a binary to execute.


``` nix
{
    apps.${system}.default = let
      serv = pkgs.writeShellApplication {
        # Our shell script name is serve
        # so it is available at $out/bin/serve
        name = "serve";
        # Caddy is a web server with a convenient CLI interface
        runtimeInputs = [pkgs.caddy];
        text = ''
          # Serve the current directory on port 8090
          caddy file-server --listen :8090 --root .
        '';
      };
    in {
      type = "app";
      # Using a derivation in here gets replaced
      # with the path to the built output
      program = "${serv}/bin/serve";
    };
}
```

From here you can run `nix run`

Dockerfiles help you build the software, but they don't really help you run or operate the software. 
Nix flakes is more akin to docker-compose, they help you compose packages written in Nix to run across machines.

you can make a flake from a template

``` shell
mkdir ~/tmp/go-demo
cd ~/tmp/go-demo
nix flake new -t templates#go-hello .
git init && git add .
```

``` nix
{
  description = "A simple Go package";

  # Nixpkgs / NixOS version to use.
  inputs.nixpkgs.url = "nixpkgs/nixos-21.11";

  outputs = { self, nixpkgs }:
    let

      # Generate a user-friendly version number.
      version = builtins.substring 0 8 self.lastModifiedDate;

      # System types to support.
      supportedSystems = [ "x86_64-linux" "x86_64-darwin" "aarch64-linux" "aarch64-darwin" ];

      # Helper function to generate an attrset '{ x86_64-linux = f "x86_64-linux"; ... }'.
      forAllSystems = nixpkgs.lib.genAttrs supportedSystems;

      # Nixpkgs instantiated for supported system types.
      nixpkgsFor = forAllSystems (system: import nixpkgs { inherit system; });

    in
    {

      # Provide some binary packages for selected system types.
      packages = forAllSystems (system:
        let
          pkgs = nixpkgsFor.${system};
        in
        {
          # The default package for 'nix build'. This makes sense if the
          # flake provides only one package or there is a clear "main"
          # package.
          default = pkgs.buildGoModule {
            pname = "go-hello";
            inherit version;
            # In 'nix develop', we don't need a copy of the source tree
            # in the Nix store.
            src = ./.;

            # This hash locks the dependencies of this package. It is
            # necessary because of how Go requires network access to resolve
            # VCS.  See https://www.tweag.io/blog/2021-03-04-gomod2nix/ for
            # details. Normally one can build with a fake sha256 and rely on native Go
            # mechanisms to tell you what the hash should be or determine what
            # it should be "out-of-band" with other tooling (eg. gomod2nix).
            # To begin with it is recommended to set this, but one must
            # remeber to bump this hash when your dependencies change.
            #vendorSha256 = pkgs.lib.fakeSha256;

            vendorSha256 = "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=";
          };
        });
    };
}
```

`$ nix build`
then

```
$ ./result/bin/go-hello
Hello Nix!
```

you can also run the default package with this command

``` shell
$ nix build .#default
```


# exposing packages as application
Additionally, you can expose a package as an application. 
This allows you to simplify that above nix build and ./result/bin/go-hello cycle into a single nix run command.

Open flake.nix in your favorite editor and let's configure go-hello to be the default app:

``` nix
# below packages

apps = forAllSystems (system: {
  default = {
      type = "app";
      program = "${self.packages.${system}.default}/bin/go-hello";
  };
});
```


``` shell
 nix run
Hello Nix!
```

One of Nix's superpowers is the ability to declaratively manage the development environment for a project so that you can be sure that everyone working on the project is using the same tools.

Flakes has the ability to specify this using the devShells flake output.

``` nix
devShells = forAllSystems (system:
  let pkgs = nixpkgsFor.${system};
  in {
    default = pkgs.mkShell {
      buildInputs = with pkgs; [ go gopls gotools go-tools ];
    };
  });
```

# external dependencies

Flake inputs let you add external dependencies to a project. 

``` nix
# Nixpkgs / NixOS version to use.
inputs.nixpkgs.url = "nixpkgs/nixos-21.11";
```

we can upgrade to unstable

``` nix
# Nixpkgs / NixOS version to use.
inputs.nixpkgs.url = "nixpkgs/nixos-unstable";
```

This also lets you pull in other Nix flakes projects,

``` nix
inputs.xess.url = "github:Xe/Xess";
inputs.xess.inputs.nixpkgs.follows = "nixpkgs";
```
- . By making Xess' nixpkgs input follows our own one, we are saying "I understand this may be incompatible, but please use this version of nixpkgs instead".

Or anything you want! A useful library to pull in is flake-utils,




# building a rust service with Nix

a flake file is just a regular nix file.  It needs to evaluate to a set with *inputs* and *outputs*


One thing a flake can have as an output is... an executable!

``` nix
# in flake.nix
{
  inputs = {
    # this is equivalent to `nixpkgs = { url = "..."; };`
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = inputs: {
    packages."x86_64-linux".default = derivation {
      name = "simple";
      builder = "${inputs.nixpkgs.legacyPackages."x86_64-linux".bash}/bin/bash";
      args = [ "-c" "echo foo > $out" ];
      src = ./.;
      system = "x86_64-linux";
    };
  };
}
```


`nix flake show`
- show outputs

we can destructue the the arguments of outputs:

``` nix
# in flake.nix
{
  inputs = {
    # this is equivalent to `nixpkgs = { url = "..."; };`
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  # now a set 👇
  outputs = { self, nixpkgs }: {
    packages."x86_64-linux".default = derivation {
      name = "simple";
      # was `inputs.nixpkgs`, now just:
      builder = "${nixpkgs.legacyPackages."x86_64-linux".bash}/bin/bash";
      args = [ "-c" "echo foo > $out" ];
      src = ./.;
      system = "x86_64-linux";
    };
  };
}
```

we can alos use let to make things tidyer

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = { self, nixpkgs }:
    let
      # define system once
      system = "x86_64-linux";
      # use it here, and bind platform-specific packages to `pkgs`
      pkgs = nixpkgs.legacyPackages.${system};
    in
    {
      # we can use `${system}` here!
      packages.${system}.default = derivation {
        name = "simple";
        # with `with`, we can just do `bash`
        builder = with pkgs; "${bash}/bin/bash";
        args = [ "-c" "echo foo > $out" ];
        src = ./.;
        system = system;
      };
    };
}
```


make it nicer

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = { self, nixpkgs }:
    let
      system = "x86_64-linux";
      name = "simple";
      src = ./.;
      pkgs = nixpkgs.legacyPackages.${system};
    in
    {
      packages.${system}.default = derivation {
        inherit system name src;
        builder = with pkgs; "${bash}/bin/bash";
        args = [ "-c" "echo foo > $out" ];
      };
    };
}
```

for a bunch of other targets

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    # we have a new input!
    flake-utils.url = "github:numtide/flake-utils";
  };
  #      it's destructured here
  outputs = { self, nixpkgs, flake-utils }:
    # calling a function from `flake-utils` that takes a lambda
    # that takes the system we're targetting
    flake-utils.lib.eachDefaultSystem (system:
      let
        # no need to define `system` anymore
        name = "simple";
        src = ./.;
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        # `eachDefaultSystem` transforms the input, our output set
        # now simply has `packages.default` which gets turned into
        # `packages.${system}.default` (for each system)
        packages.default = derivation {
          inherit system name src;
          builder = with pkgs; "${bash}/bin/bash";
          args = [ "-c" "echo foo > $out" ];
        };
      }
    );
}
```

another example
``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };
  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        name = "simple";
        src = ./.;
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        packages.default = derivation {
          inherit system name src;
          builder = with pkgs; "${bash}/bin/bash";
          args = [ "-c" "echo foo > $out" ];
        };
        packages.shaka-packager =
          let
            version = "2.6.1";
            inherit (pkgs) stdenv lib;
          in
          stdenv.mkDerivation
            {
              name = "shaka-packager-${version}";

              # https://nixos.wiki/wiki/Packaging/Binaries
              src = pkgs.fetchurl {
                url =
                  "https://github.com/shaka-project/shaka-packager/releases/download/v${version}/packager-linux-x64";
                sha256 = "sha256-MoMX6PEtvPmloXJwRpnC2lHlT+tozsV4dmbCqweyyI0=";
              };

              dontUnpack = true;
              sourceRoot = ".";

              installPhase = ''
                install -m755 -D $src $out/bin/shaka-packager
              '';

              meta = with nixpkgs.lib; {
                homepage = "https://shaka-project.github.io/shaka-packager/html/";
                description =
                  "Media packaging framework for VOD and Live DASH and HLS applications";
                platforms = platforms.linux;
              };
            };
      }
    );
}
```


not for all environments

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };
  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem
      (system:
        let
          name = "simple";
          src = ./.;
          pkgs = nixpkgs.legacyPackages.${system};
        in
        {
          packages = {
            default = derivation {
              inherit system name src;
              builder = with pkgs; "${bash}/bin/bash";
              args = [ "-c" "echo foo > $out" ];
            };
          } // (if system == "x86_64-linux" then {
            shaka-packager =
              let
                version = "2.6.1";
                pkgs = nixpkgs.legacyPackages.x86_64-linux;
                inherit (pkgs) stdenv lib;
              in
              stdenv.mkDerivation
                {
                  name = "shaka-packager-${version}";

                  # https://nixos.wiki/wiki/Packaging/Binaries
                  src = pkgs.fetchurl {
                    url =
                      "https://github.com/shaka-project/shaka-packager/releases/download/v${version}/packager-linux-x64";
                    sha256 = "sha256-MoMX6PEtvPmloXJwRpnC2lHlT+tozsV4dmbCqweyyI0=";
                  };

                  dontUnpack = true;
                  sourceRoot = ".";

                  installPhase = ''
                    install -m755 -D $src $out/bin/shaka-packager
                  '';

                  meta = with nixpkgs.lib; {
                    homepage = "https://shaka-project.github.io/shaka-packager/html/";
                    description =
                      "Media packaging framework for VOD and Live DASH and HLS applications";
                    platforms = platforms.linux;
                  };
                };
          } else { });
        }
      );
}
```


# overlays.
- the result of `import <nixpkgs>` is a function that can be called with a set

- overlay provide packages that aren't in nixpkgs by default

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };
  outputs = { self, nixpkgs, flake-utils, rust-overlay }:
    flake-utils.lib.eachDefaultSystem
      (system:
        let
          overlays = [ (import rust-overlay) ];
          pkgs = import nixpkgs {
            inherit system overlays;
          };
        in
        with pkgs;
        {
          devShells.default = mkShell {
            buildInputs = [ rust-bin.stable.latest.default ];
          };
        }
      );
}
```

so that we don't import nixpkgs and flake-utils twice
gets rid of duplicates
``` nix
# in flake.nix (only inputs shown)
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        flake-utils.follows = "flake-utils";
      };
    };
  };
```
- avoid rebuild the world situations


# Nix Flakes

Flakes allow to define inputs (you can think of them as dependencies) and outputs of packages in a declarative way.

`nix flake new` can be used to create a new flake, it also supports templates!

`nix flake new . -t templates#rust`

There are 3 top level attributes and various sub-attributes:

``` nix
{
	description = "I am an optional description";
	
	# inputs contains all the dependencies of the flake
	inputs = {
		nixpkgs.url = "github:NixOs/nixpkgs" # this is set by default
		flake-utils.url = "github:numtide/flake-utils" # this is another flake
	};
	
	# outputs is a function that has the inputs are passed as parameters
	outputs = { self, nixpkgs, flake-utils }:

		packages = ... # packages exposed by this flake, used by nix build
		defaultPackage = ... # package called when nix build has no arguments
		
		apps = ... # apps exposed by this flake, used by nix run
		defaultApp = ... # app called when nix run has no arguments
		
		devShell = ... # this is the definition of the nix-shell
		
    ... # there's much more, see the NixOS wiki for details
	
	}

}
```


Here’s an example of a basic development shell with ripgrep:

``` nix
{
  description = "A basic devShell";

  outputs = { self, nixpkgs }:
    let pkgs = nixpkgs.legacyPackages.x86_64-linux;

    in {
      devShell.x86_64-linux = pkgs.mkShell {
        buildInputs = with pkgs; [ ripgrep ];

        shellHook = ''
          echo "shell with ripgrep"
        '';
      };

    };
}
```

To avoid having to repeat our declaration for each architecture we intend to support we can use eachDefaultSystem from flake-utils .

``` nix
{
  description = "A basic devShell using flake-utils each";

  inputs.flake-utils.url = "github:numtide/flake-utils";

  outputs = { self, nixpkgs, flake-utils }:
      flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system}; in
      rec {
        devShell = pkgs.mkShell {
          buildInputs = with pkgs; [ ripgrep ];

          shellHook = ''
            echo "shell with ripgrep"
          '';
        };
      }
    );
}
```

# Pratical Nix Flakes

Briefly speaking, Nix is a package manager and a build system

There is a vast repository of packages for Nix called nixpkgs, 
and a GNU/Linux distribution that extends the ideas of Nix to the OS level called NixOS.

Nix building instructions are called “derivations” and are written in the Nix programming language
-  they can then be deterministically “realised” 
- Derivations can only depend on a pre-defined set of inputs, so they are somewhat reproducible

Flakes are self-contained units that have inputs (dependencies) and outputs (packages, deployment instructions, Nix functions for use in other flakes). 

 Flakes have great reproducibility because they are only allowed to depend on their inputs and they pin the exact versions of said inputs in a lockfile.

test hello
`nix shell github:nixos/nixpkgs/nixpkgs-unstable#hello`

Nix evaluates a derivation from the expression, hashes its contents, and queries all the caches it knows to see if someone has the derivation with this hash cached

all Nix derivations have “store paths” (paths located in /nix/store)

 it has the ability to provide a build environment for its derivations.
 
 Nix implements stateful “profiles” to allow users to “permanently” install stuff.
 
 ``` shell
 nix profile install nixpkgs#hello
nix profile list
nix profile update hello
nix profile remove hello
 ```

`nix flake show`
This command takes a flake URI and prints all the outputs of the flake

`nix flake clone` 
will clone the flake source to a local directory, similar to git clone

# nix object

``` nix
{
  hello = "world";
  foo = "bar";
}
```

``` nix
{
  foo.bar = "baz";
}
```

``` nix
{
  foo = { bar = "baz"; };
}
```

# let

``` nix
let
  my_attrset = { foo = "bar"; };
in my_attrset.foo
```

# function

``` nix
{ a, b }: a + b
```

``` nix
let
  f = { a, b }: a + b;
in f { a = 10; b = 20; }
```

function with multiple arguments, use currying
``` nix
let
  f = a: b: a + b;
in f 10 20
```

# basic flake structure 

A Nix flake is a directory that contains a flake.nix file. That file must contain an attribute set with one required attribute – outputs – and optionally description and inputs.

outputs is a function that takes an attribute set of inputs

most simple example

``` nix
{
  outputs = { self }: { };
}
```

``` nix
{
  outputs = { self }: {
    foo = "bar";
  };
}
```

` nix eval .#foo`

give it some inputs
``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: { };
}
```


While the attribute set that outputs returns may contain arbitrary attributes, some standard outputs are understood by various nix utilities

for example packages

``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.hello = /* something here */;
  };
}
```
- all flake outputs that have anything to do with packages must specify the platform explicitly in some way


``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;
  };
}
```

`nix build .#hello`
and then
`nix run .#hello`

Another thing we can add is a “development” shell containing some utilities that might be useful when working on our flake.

there is a special output for such development shells, called devShell. 


here is also a function for building such shells in nixpkg

``` nix
{
  inputs = { nixpkgs.url = "github:nixos/nixpkgs"; };

  outputs = { self, nixpkgs }:
    let pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in {
      packages.x86_64-linux.hello = pkgs.hello;

      devShell.x86_64-linux =
        pkgs.mkShell { buildInputs = [ self.packages.x86_64-linux.hello pkgs.cowsay ]; };
   };
}
```

run it in zsh
`nix shell -c zsh`

# flake-utils

```nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.hello = pkgs.hello;

        devShell = pkgs.mkShell { buildInputs = [ pkgs.hello pkgs.cowsay ]; };
      });
}
```


# templates 

`nix flake init -t`

`nix flake init -t github:serokell/templates#haskell-cabal2nix`

``` nix
{
  description = "My haskell application";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        haskellPackages = pkgs.haskellPackages;

        jailbreakUnbreak = pkg:
          pkgs.haskell.lib.doJailbreak (pkg.overrideAttrs (_: { meta = { }; }));

        packageName = throw "put your package name here!";
      in {
        packages.${packageName} = # (ref:haskell-package-def)
          haskellPackages.callCabal2nix packageName self rec {
            # Dependency overrides go here
          };

        defaultPackage = self.packages.${system}.${packageName};

        devShell = pkgs.mkShell {
          buildInputs = with haskellPackages; [
            haskell-language-server
            ghcid
            cabal-install
          ];
          inputsFrom = builtins.attrValues self.packages.${system};
        };
      });
}
```

python

``` nix
{
  description = "My Python application";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        customOverrides = self: super: {
          # Overrides go here
        };

        app = pkgs.poetry2nix.mkPoetryApplication {
          projectDir = ./.;
          overrides =
            [ pkgs.poetry2nix.defaultPoetryOverrides customOverrides ];
        };

        packageName = throw "put your package name here";
      in {
        packages.${packageName} = app;

        # set package as default
        defaultPackage = self.packages.${system}.${packageName};

        # provide package as imput
        devShell = pkgs.mkShell {
          buildInputs = with pkgs; [ poetry ];
          inputsFrom = builtins.attrValues self.packages.${system};
        };
      });
}
```

# nix series

There's no containerization going on (no user namespaces), no virtual machines, no nothing: it's just plain old executables, that only refer to things inside the /nix/store.

 what's that long hash about it? It's derived from the inputs, which means, paths either never clash (because they have different inputs), 
 
# home-manager

manage your home configuration
- packages
- dotfiles???
- environment variables
- services

it uses *nix langage* and *nix package manager* 

standalone installation
- just a program

first install nix

setup
`nix run home-manager -- init --switch .`
- generates two file *home.nix* and *flake.nix*

activate
`home-manger switch --flake .#nixhero-home`

`home-manager generation`
- show generations of your config

`nix-collect-garbage -d`
- remove unused packages

setup a program

``` nix
programs.git = {
  enable = true;
  userName = "as;lfj";
  userEmail = "...";
}
```

1. create a directory for home-manger
`mkdir wsl-home`

2. setup nix shell with home-manger 
`nix shell nixpkgs#home-manager`
`home-manager --version`

3. initiate home manger
`home-manger init .`
- this will create two file
*flake.nix*
*home.nix*

4. use the config
`home-manger switch --flake .#<target>`

5. setup packages
open home.nix

```nix
home.packages = [
  pkgs.hello
]
```

```nix
programs.bash.enable = true
porgrams.neovim.enable = true
```

you can use home-manger as a package
and setup through nix shell


create directory for home manger
`mkdir home-manger1`

setup home manger
`nix run home-manger -- init --switch .`

you can now run home-manger
`home-manger --version`

two files were created in your directory
- flake.nix
- home.nix


Flake.nix
```nix
homConfigureations."homemanger" = home-manager.lib.homeManagerConfiguration {
  inherit pkgs;
  modules = [ ./home.nix ];
}
```

activate your configuration
```nix
home-manger switch --flake .#homemangager
```
- activate configuration
- specifies which configuration
- .#homemanager
  + use flake in current directory and profile .#hommanager


home.nix
```nix
{ 
	home.packages = [
		# pkgs.hello
	]
}
```

this creates a file
```nix
{
	home.file.<path>.text = "";
}
```
- this is a symlink to /nix/store/...

configure your own bash
'''nix
{
	programs.fzf.enable = true;
	programs.bash.enable = true;
}
'''

setup services
```nix
service.<service>.enable = true
```

geneartion
`home-manager generation`

remove unused generations
`nix-collect-garbage -d`


`nix shell nixpkgs#home-manager`
`home-manger --version`
`home-manger init .`
`home-manager switch --flake .#<target>`

```nix
home.package = [
  pkgs.neofetch
]

programs.bash.enable = true
```
- allow home-manger to configure bash

`home-manger switch --flake .#<name> -b backup.bash.file`

example build npm

``` nix
{
  packages = forAllSystems ({ pkgs }: {
    default = pkgs.buildNpmPackage {
      name = "zero-to-nix-javascript";

      buildInputs = with pkgs; [
        nodejs_18
      ];

      src = self;

      npmDepsHash = "sha256-A/q4C8Ox1InaJ/320+pU9uBUv6zqTKlzzOmJUvzBOnI=";

      npmBuild = "npm run build";

      installPhase = ''
        mkdir $out
        cp dist/index.html $out
      '';
    };
  });
}
```

``` nix
{
  description = "JavaScript example flake for Zero to Nix";

  inputs = {
    nixpkgs.url = "https://flakehub.com/f/NixOS/nixpkgs/0.2405.*.tar.gz";
  };

  outputs = { self, nixpkgs }:
    let
      # Systems supported
      allSystems = [
        "x86_64-linux" # 64-bit Intel/AMD Linux
        "aarch64-linux" # 64-bit ARM Linux
        "x86_64-darwin" # 64-bit Intel macOS
        "aarch64-darwin" # 64-bit ARM macOS
      ];

      # Helper to provide system-specific attributes
      forAllSystems = f: nixpkgs.lib.genAttrs allSystems (system: f {
        pkgs = import nixpkgs { inherit system; };
      });
    in
    {
      packages = forAllSystems ({ pkgs }: {
        default = pkgs.buildNpmPackage {
          name = "zero-to-nix-javascript";

          buildInputs = with pkgs; [
            nodejs_latest
          ];

          src = self;

          npmDepsHash = "sha256-RR0uypDfVTJ/EMOxUnxdLnBbEZasHO+LqLkRAb2mDyg=";

          npmBuild = "npm run build";

          installPhase = ''
            mkdir $out
            cp dist/index.html $out
          '';
        };
      });
    };
}
```


``` nix
{ lib, buildNpmPackage, fetchFromGitHub }:

buildNpmPackage rec {
  pname = "flood";
  version = "4.7.0";

  src = fetchFromGitHub {
    owner = "jesec";
    repo = pname;
    rev = "v${version}";
    hash = "sha256-BR+ZGkBBfd0dSQqAvujsbgsEPFYw/ThrylxUbOksYxM=";
  };

  npmDepsHash = "sha256-tuEfyePwlOy2/mOPdXbqJskO6IowvAP4DWg8xSZwbJw=";

  # The prepack script runs the build script, which we'd rather do in the build phase.
  npmPackFlags = [ "--ignore-scripts" ];

  NODE_OPTIONS = "--openssl-legacy-provider";

  meta = {
    description = "Modern web UI for various torrent clients with a Node.js backend and React frontend";
    homepage = "https://flood.js.org";
    license = lib.licenses.gpl3Only;
    maintainers = with lib.maintainers; [ winter ];
  };
}
```

https://github.com/NixOS/nixpkgs/blob/master/doc/languages-frameworks/javascript.section.md 

buildNpmPackage function, which is a wrapper around Nix’s built-in derivation function.

create your project into a flake

``` nix
nix run "https://flakehub.com/f/DeterminateSystems/fh/*" -- init
```


# Nix 
a language, package manager, os

# The Nix Language
Nix as a programming language can be thought of as a kind of “JSON, but with functions”. 
 
functions are called that assign values to fields in attribute sets, which in turn may get assigned to other values

assignments

``` nix
{
  my_value = my_function 2 3;
}
```

functions

``` nix
{
  my_function = x: y: x + y;
}
```

attribute sets and lists

``` nix
rec {
  number_key = 5;
  list_key = [ number_key true "Hello" ];
}
```
- The rec keyword allows the attribute set to reference itself.

# Nix flakes
Channels will continue be the “official” way of using Nix for the foreseeable future. 
however it is recomened to learn about flakes

A Nix flake is a directory with a flake.nix and flake.lock at the root 
that outputs Nix expressions that others can use to do things like 
build packages, run programs, use development environments, or stand up NixOS systems. 
If necessary, flakes can use the outputs of other flakes as inputs.

 They take Nix expressions as input and output things that Nix can use, like *package definitions*, *development environments*, or *NixOS configurations*.

Flake inputs are Nix dependencies that a flake needs to be built.

Furthermore, inputs can modify each other’s inputs to make sure that, for example, multiple dependencies all rely on the same version of nixpkgs. This is done via the inputs.<input>.follows attribute.

All flake inputs are pinned to specific revisions in a lockfile called flake.lock.

inputs you can use
nixpkgs	github:NixOS/nixpkgs/nixpkgs-unstable
flake-utils	github:numtide/flake-utils
home-manager	github:nix-community/home-manager

Flake outputs are what a flake produces as part of its build. 

Nix packages
Nix development environments
NixOS configurations
Nix templates

Flake outputs are defined by a function, which takes an attribute set as input,

In addition to things like packages and NixOS configurations, 
flakes can also output Nix functions for use elsewhere. 
Nixpkgs, for example, outputs many helper functions via the lib attribute.

The convention of using lib to output functions is observed not just by Nixpkgs but by many other Nix projects

``` nix
{
  outputs = { self }: {
    lib = {
      sayHello = name: "Hello there, ${name}!";
    };
  };
}
```
- Another Nix flake could then specify this flake as an input and use sayHello for whatever purpose.

system specific
``` nix
{
  outputs = { self, nixpkgs }: let
    # Declare the system
    system = "x86_64-linux";
    # Use a system-specific version of Nixpkgs
    pkgs = import nixpkgs { inherit system; };
  in {
    # Output `ponysay` as the default package of the flake
    packages.${system}.default = pkgs.ponysay;
  };
}
```

for all systems

``` nix
{
  outputs = { self, nixpkgs }: let
    # The set of systems to provide outputs for
    allSystems = [ "x86_64-linux" "aarch64-linux" "x86_64-darwin" "aarch64-darwin" ];

    # A function that provides a system-specific Nixpkgs for the desired systems
    forAllSystems = f: nixpkgs.lib.genAttrs allSystems (system: f {
      pkgs = import nixpkgs { inherit system; };
    });
  in {
    packages = forAllSystems ({ pkgs }: {
      default = {
        # Package definition
      };
    });
  };
}
```

# Derivations
Build instructions for Nix packages

A derivation is an instruction that Nix uses to realise a Nix package. 

. They’re created using a special derivation function in the Nix language. 

You may find it helpful to think of a derivation as the plan or blueprint for a Nix package.

In the Nix language, derivations are created using the derivation function.

``` nix
derivation ::
    { system   : String
    , name     : String
    , builder  : Path | Derivation
    , ?args    : [String]
    , ?outputs : [String]
    } -> Derivation
```

example

``` nix
derivation {
  # A name for the derivation (whatever you choose)
  name = "hello-text";
  # The system realising the derivation
  system = "x86_64-linux";
  # The program realising the derivation
  builder = "bash";
  # Arguments passed to the builder program
  args = ["-c" "mkdir $out && echo Hello world > $out/hello.txt"]
};
```

There are two special variables to be aware of when writing derivations:

*$out* represents the root of the directory structure for build output.
*$src* represents the build sources

Most derivations in the Nix ecosystem are based on the mkDerivation function 

While you can create derivations using the raw derivation function, it’s far more common to use a wrapper function around it. Perhaps the most commonly used wrapper function is stdenv.mkDerivation.

Outside of stdenv.mkDerivation, there are many custom derivation wrappers for specific languages, frameworks, and more (and many of those actually wrap stdenv.mkDerivation). 

buildGoModule for Go
buildRustPackage for Rust
buildPythonApplication for Python

# Caching

y Nix uses already-built artifacts rather than building some artifacts unnecessarily

It computes a hash for the derivation and, using that hash, as a Nix store path 

With a store path in hand, Nix determines whether the derivation has already been built

It checks a if the store path exists in a configured binary cache.

If the store path exists neither in a configured Nix store nor in a configured binary cache, Nix builds the derivation from scratch,

In addition to the local Nix store, you can also cache Nix artifacts using remote Nix stores called binary caches that serve pre-built binaries via HTTP. 

By default, Nix uses cache.nixos.org as a binary cache

# closures

A Nix package's dependency tree

In Nix, a package’s closure encapsulates all of the packages required to build or run it 

Nix closures come in two different types:

Build-time closures include everything necessary to build the package.
- for example gcc

Runtime closures include everything necessary to run the package.
- for example gtk

# packages
Software bundles built using nix

Nix packages are self-contained bundles that are built using derivations

# the nix store

An on-disk storage system used by Nix to build, store, and cache packages and other artifacts

The Nix store is a storage system in your filesystem with its root at /nix/store by default. 

the Nix daemon stores several things in the Nix store:

* Derivations: stand-alone files suffixed with .drv such as /nix/store/<hash>-my-package.drv
* The products of derivations: a folder containing build outputs such as /nix/store/<hash>-my-package/
* Patches: stand-alone files suffixed with .patch such as /nix/store/<hash>-my-package.patch

/nix/store/sglc12hc6pc68w5ppn2k56n6jcpaci1-my-package-1.0
1. store path
2. input hash: drived from inputs to derivation
3. package name

The hash ensures that two packages with the same name have completely different paths if the inputs to the package differ at all. 

# the nix language

 Nix as a programming language can be thought of as a kind of “JSON, but with functions”. 
 
 instead functions are called that assign values to fields in attribute sets
 
# declarative programming
 
t emphasizes what you want to build rather than how things are built

In declarative programming a user instructs the computer what to do, not how to do it.

# reproducibility

The ability to consistently and repeatedly produce the same build outputs from the same build inputs

Reproducibility is a software design concept, where an operation for the same inputs yields the same output. 


``` nix
{ stdenv, fetchGit }:

stdenv.mkDerivation {
  name = "my-package";
  src = fetchgit {
    url = "https://github.com/DeterminateSystems/riff";
    sha256 = "sha256-7mnx7J0AacL2P2mNuNNB+kKE7VR8nniVG+PSrwpZixE=";
  };
}
```
- The reproducibility of mkDerivation is guaranteed because the output of fetchgit is pinned to a particular hash.
- The output of fetchgit is guaranteed because its output is fixed to a particular hash. 

# channels
Nix's original but no longer recommended system for discovering and depending on Nix expressions

A Nix channel is a mechanism used by the legacy Nix CLI to keep Nixpkgs up to date. In the new Nix CLI, channels have been replaced by flakes.

A channel is a URL that points to some Nix code, such as https://nixos.org/channels/nixos-unstable

You can configure Nix to fetch a channel automatically:
``` nix
nix-channel --add https://nixos.org/channels/nixos-unstable
```

You can then run this to have Nix fetch all channels that you’ve configured:
``` nix
nix-channel --update
```

The Nix code in the channels is unpacked into ~/.nix-defexpr/channels where it can be found by legacy CLI commands such as nix-env.

The problem with channels is that they do not provide any guarantees about what inputs are actually used in a particular build.
 A channel URL such as channel:nixos-22.11 can contain different Nix code at different points in time. 
 
# Development environments

A Nix development environment is a derivation which builds a shell system environment. 

# Hermeticity

Isolating build environments from the host to guarantee reproducible builds

# Incremental builds

Package builds that cut out unnecessary steps

Incremental builds are build processes that don’t need to build the entire dependency tree of a software artifact every time because they use mechanisms like intelligent caching to avoid rebuilding artifacts that are already available. 

Nix can then check to see if one of these places already has the artifact:

The local Nix store
One of your configured binary caches (if any)

# NixOS 

A Linux distribution based on the Nix package manager and guided by Nix's core principlse

your configuratione is in a configuration.nix file stored in /etc/nixos. 

example

``` nix
{ pkgs, ... }: # A pinned version of Nixpkgs passed to the configuration by Nix

{
  # Enable Nix flakes and the unified Nix CLI
  nix.settings = {
    experimental-features = "nix-command flakes";
  };

  # Networking configuration
  networking.hostName = "justme-dev-box";

  # Enable OpenSSH
  services.openssh.enable = true;

  # Root filesystem
  fileSystems."/" = {
    device = "/dev/sda1";
    fsType = "ext4";
  };

  # Create a user
  users.users.justme = {
    isNormalUser = true;
    initialPassword = "changemeplz";
  };

  # CLI tools, language runtimes, shells, and other desired packages
  environment.systemPackages = with pkgs; [
    curl
    jq
    wget
    git
    python
    openssl
    zsh
  ];
}
```

This command applies the configuration above:
``` nix
nixos-rebuild switch
```

# modules

A module is a piece of Nix code that you can configure to produce configuration.

 a module is a function that takes an attribute set and returns another attribute set.

example nix module
``` nix
{ lib, config, pkgs, ... }:

{
  imports = [];
  config = {};
  options = {};
}
```

# Nixpkgs

A collection of tens of thousands of Nix packages and build utilities for the Nix language

Nixpkgs (pronounced “Nix packages”) is a big collection of Nix expressions, packages (who’d have thought…), and build utilities for the Nix ecosystem. It is sometimes also called a “Nix standard library” (or Nix stdlib).

Nixpkgs is a mono repo, containing over 80,000 package definitions and the utilities 

Many tools in the Nix ecosystem depend on this standard library to function.

# Sandboxing

Isolating the Nix build process from everything else on your system


Whenever Nix builds anything, it sandboxes that process from everything else on the host system. 

# System specificity

t all Nix derivations have a system property that describes which architecture the package is built on

 specifies which system the derivation is built on
 
# Realisation

The process whereby Nix turns the build instruction in a derivation into a build output in the Nix store

Realisation is the process whereby a Nix derivation is transformed into a package. While a derivation is essentially a plan for a package, realisation is the build process turns that plan into an actual output directory

When you run nix build to build a package, the Nix CLI first looks at the derivation function for the function and transforms it into an intermediate .drv file, 
which is essentially a formal representation of the derivation function. 
All .drv files are stored in the Nix store with a hashed path, such as /nix/store/m2nb4d0pfydr8bq5ww1yqbrkvvf18zbl-perl-5.36.0.drv, which ensures that any change in a derivation function results in a new .drv file with a new path. 
The CLI then uses the .drv file as the blueprint for the actual build process

Once Nix has built a .drv file for the derivation, it uses the encoded instructions in the file to actually build the package in a sandboxed environment,

# NixOS & Flakes Book

One of NixOS's major advantages over other distributions lies in its reproducibility and declarative configuration

Inspired by package managers like npm and Cargo, Flakes uses flake.nix to record all external dependencies and flake.lock to lock their versions.

"declarative configuration" means that users only need to declare the desired outcome

built on top of the Nix package manager,

 It employs declarative Nix configuration files to describe the entire state of the operating system.
 
 
 A significant community project called home-manager is designed to manage user-level packages and configuration files within the user's home directory.
 
rebuild with flake
``` nix
sudo nixos-rebuild switch --flake .
```

 the configuration modified on any host can be seamlessly synchronized to other hosts through Git.
 
 These configurations can be managed directly with Git, allowing the system to be restored to any historical state as long as the configuration files are preserved
 
 It is possible to roll back to any previous system state
 
 
 The default configuration file for NixOS is located at /etc/nixos/configuration.nix.
 
 
we need to manually edit the */etc/nixos/configuration.nix* file and then execute *sudo nixos-rebuild switch* to apply the modified configuration. 

While */etc/nixos/configuration.nix* is the classic method for configuring NixOS, it relies on data sources configured by nix-channel and lacks a version-locking mechanism, making it challenging to ensure the reproducibility of the system. 

enable openssh
``` nix
# Edit this configuration file to define what should be installed on
# your system.  Help is available in the configuration.nix(5) man page
# and in the NixOS manual (accessible by running ‘nixos-help’).
{ config, pkgs, ... }:

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  # Omit previous configuration settings...

  # Add user 'ryan'
  users.users.ryan = {
    isNormalUser = true;
    description = "ryan";
    extraGroups = [ "networkmanager" "wheel" ];
    openssh.authorizedKeys.keys = [
        # Replace with your own public key
        "ssh-ed25519 <some-public-key> ryan@ryan-pc"
    ];
    packages = with pkgs; [
      firefox
    #  thunderbird
    ];
  };

  # Enable the OpenSSH daemon.
  services.openssh = {
    enable = true;
    settings = {
      X11Forwarding = true;
      PermitRootLogin = "no"; # disable root login
      PasswordAuthentication = false; # disable password login
    };
    openFirewall = true;
  };

  # Omit the rest of the configuration...
}
```

``` shell
sudo nixos-rebuild switch
```
- You can always try to add *--show-trace* *--print-build-logs* *--verbose* to the *nixos-rebuild* command to get the detailed error message 

# Intro to Flakes

Flakes introduce *flake.nix*, similar to *package.json*, to describe the dependencies between Nix packages and how to build projects. Additionally, it provides *flake.lock*, akin to *package-lock.json*, to lock the versions of dependencies, ensuring project reproducibility.

Nix introduced two experimental features, nix-command and flakes

These features bring forth a new command-line interface
a standardized Nix package structure definition (known as the Flakes feature), and features like flake.lock, similar to version lock files in cargo/npm.

The current Nix New CLI (the nix-command experimental feature) is tightly coupled with the Flakes experimental feature. 

using Flakes essentially requires the use of the New CLI. 

In Flakes, The functionality of nix-channel is entirely replaced by the inputs section in flake.nix.

nix-collect-garbage: Garbage collection command used to clean up unused Store Objects in /nix/store.

There is a similar command in the New CLI, nix store gc --debug, but it does not clean the profile generations,

enable flakes for nixos

``` nix
{ config, pkgs, ... }:

{
  imports = [
    # Include the results of the hardware scan.
    ./hardware-configuration.nix
  ];

  # ......

  # Enable the Flakes feature and the accompanying new nix command-line tool
  nix.settings.experimental-features = [ "nix-command" "flakes" ];
  environment.systemPackages = with pkgs; [
    # Flakes clones its dependencies through the git command,
    # so git must be installed first
    git
    vim
    wget
  ];
  # Set the default editor to vim
  environment.variables.EDITOR = "vim";

  # ......
}
```
- After making these changes, run sudo nixos-rebuild switch to apply the modifications. Then, you can use the Flakes feature to manage your system configuration.

After enabling the Flakes feature, the sudo nixos-rebuild switch command will prioritize reading the /etc/nixos/flake.nix file, and if it's not found, it will attempt to use /etc/nixos/configuration.nix.

setup basic template

``` nix
nix flake init -t templates#full
```

basic setup

``` nix
{
  description = "A simple NixOS flake";

  inputs = {
    # NixOS official package source, using the nixos-24.11 branch here
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.11";
  };

  outputs = { self, nixpkgs, ... }@inputs: {
    # Please replace my-nixos with your hostname
    nixosConfigurations.my-nixos = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        # Import the previous configuration.nix we used,
        # so the old configuration file still takes effect
        ./configuration.nix
      ];
    };
  };
}
```
- If your system's hostname is not my-nixos, you need to modify the name of nixosConfigurations in flake.nix

show log when building flake or nixos
`nix build --show-trace --print-build-logs --verbose` 
