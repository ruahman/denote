---
title:      "nix"
date:       2024-11-20T09:23:51-04:00
tags:       []
identifier: "20241120T092351"
signature:  ""
---

Nix from first principles

https://tonyfinn.com/blog/nix-from-first-principles-flake-edition/

setup nix
``` shell
sh <(curl -L https://nixos.org/nix/install) --daemon

```

The default on Linux and MacOS is to do what's called a multi-user install, where Nix packages are available to all users. 


To enable these flakes, edit /etc/nix/nix.conf and add/modify the following line:

The multi-user install creates a directory /nix, which all packages are installed into. 

``` ini
experimental-features = nix-command flakes

```

# Nix Package Manager CLI 

The foundational part of Nix is the Nix package manager. 
This is a tool that allows you to install packages.

To install your first package, run the nix profile install command. 

`nix profile install nixpkgs#ripgrep`

install multiple packages 

`nix profile install nixpkgs#fzf nixpkgs#jq`

By default, nix profile will set itself up in your ~/.nix-profile directory.

to list what you installed
` nix profile list`

to update a specific package
`nix profile upgrade <pkg reference>`

show the history of your profile
`nix profile history`

roleback your profile
`nix profile rollback`

go back forward
`nix profile rollback --to 2`

garbage collect.
This will delete packages that are only used by profiles or generations that have been deleted.
`nix store gc`

# Nixlang

to start experimenting
`nix repl`

 since the language was designed for package management, it also has some first class data types that other languages do not. The most common of these is the path.

 ```shell 
 nix-repl> ./README.md
/home/tony/code/nix-guide/README.md
 ```

sets

``` shell
nix-repl> { a = 1; b = 2; }
```

 functions are written as a argument: expression and called by using the function name and a space.

 ``` shell
 nix-repl> x = arg: { foo = arg; }

nix-repl> x 123
{ foo = 123; }
 ```

You can use destructuring to extract fields from sets as arguments. 

``` shell
nix-repl> x = { foo, bar }: {a = foo; b = bar; }

nix-repl> x { foo = 1; bar = 2; }
{ a = 1; b = 2; }
```

But what if you want multiple positional arguments? Similar to languages like Haskell, functions use what is known as currying to handle multiple arguments. This means that any function which take multiple arguments is actually represented as functions which take a single argument and return another function. 

``` nix
adder = amountToAdd: x: amountToAdd + x
```

- This is effectively a function which takes an argument amountToAdd, then returns the function x: amountToAdd + x


 what if you have some value you want to use multiple times?
 In that case you can use a let expression to create what is called a binding.
 
 ``` nix
 # "abcabc"
let x = "abc"; in x + x;

# "abcxyz"
let x = "abc"; y = "xyz"; in x + y; 
 ```
-  The values are only available for the single expression after the let keyword.

 the with expression takes all the fields of a set and makes them available as bindings within the expression following the with.
 `with <some-set>; <expression>`
 
 ``` nix
 let longNameSet = {
    foo = 1;
    bar = 2;
}; in ( # Brackets optional, added for clarity
    with longNameSet; {
        sum = foo + bar;
    }
)
 ```

inherit is used to copy values from an outer scope into a set being constructed.

``` nix
let someVariableWithALongName = 5; in {
    inherit someVariableWithALongName;
}
```

is the same as this

``` nix
let someVariableWithALongName = 5; in {
    someVariableWithALongName = someVariableWithALongName;
}
```

# derivations

A Nix derivation is a special type of set created from the derivation function which describes how to obtain and build a package. 
- a special set used to obtain and build a package

The Nix package manger will then evaluate this derivation, and use the result to copy the built package into the Nix store

The subfolders are hashes derived from the inputs to the expression that built the stored packages.

 
 derivation itself takes a set as its argument, which it will expand out into the full derivation when evaluted.
 
 system: x86_64-linux or aarch64-darwin
 name: s a string which gives the package a name
 builder:  is a program that is run to build the derivation.
 

a nix expression which defines the derivation 
``` nix
derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    # Replace with x86_64-darwin, aarch64-darwin or aarch64-linux if needed
    system = "x86_64-linux";
}
```
- you can run `nix build` 


You run the nix build command. 

 The derivation is built in an isolated environment, and since you haven't included anything in that environment, you get a bourne compatible shell and not much else. Since cp is not a shell builtin [1], you'll need to provide the command.

Bootstrapping

include cp for builder
``` nix
derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    # busybox_CP will be copied to the nix store, and the path 
    # will be put in the $cp env variable.
    cp = ./busybox_CP; 
}
```

download cp and chmod

``` nix
let 
  fetchurl = import <nix/fetchurl.nix>;
in derivation {
    builder = ./builder.sh;
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    cp = fetchurl {
      # Download from the busybox server
      url = "https://www.busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox_CP";
      # Check the downloaded file against the hash so Nix knows if the build is not reproducing
      # Download the file once and use `nix hash to-base32 $(nix hash path busybox_CP)`
      # to find the value to put here
      sha256 = "0mq1487x7aaz89211wrc810k9d51nsfi7jwfy56lg3p20m54r22a";
      # Have Nix make the file executable on download
      executable = true; 
    };
    chmod = fetchurl {
      url = "https://www.busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox_CHMOD";
      sha256 = "06fp9hqf0cxjqvs9hjg5n81lm5yhkp6iwiaa74j4cfg0wbf7d8fc";
      executable = true;
    };
}
```

# Nixpkgs

the default execution environment is incredibly barebones, to the point that you needed to include such fundamental tools as chmod and cp

If that process had to be repeated by every Nix user, it would be very inconvenient. Luckily, there is nixpkgs, which provides a number of packages that the community has already built

 stdenv.mkDerivation. This is a function that is an enhanced version of the built in derivation.
 
 It does the bootstrapping for you ensuring you have a decent minimal environment to build on. 
 
 It provides an easy way to add extra dependencies to your specific derivation and includes them in the path so you don't have to use the $cp, $chmod variables in the scripts like was required last time.
 
 It provides a default builder which runs in bash and does a ./configure && make installation, with some variables that lets you override parts of it without having to write a whole new script
 
 ``` nix
 let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/0b20bf89e0035b6d62ad58f9db8fdbc99c2b01e8.tar.gz") {};
in pkgs.stdenv.mkDerivation {
    src = ./hello.sh;
    name = "hello-1.0";
    system = "x86_64-linux";
    dontUnpack = true;
    installPhase = ''
    cp $src $out
    chmod +x $out
    '';
}
 ```
 
There's no builder provided - in this example the standard builder provided by the stdenv is used, with one phase that is overridden from the .nix file.

The installPhase option is what overrides this one phase. 


The dontUnpack attribute also tells the builder not to try unpack the source. Since most software sources have more than one file, the standard builder defaults to treating the src as an archive and trying to unpack it. Here the src is just a shell script, so that unpacking is not required.
- source is not an archive so you don't need to unpack it. 
 
use the package to build
 ``` nix
 let pkgs = import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/0b20bf89e0035b6d62ad58f9db8fdbc99c2b01e8.tar.gz") {};
in pkgs.stdenv.mkDerivation {
    src = ./rust-hello;
    name = "rust-hello-1.0";
    system = "x86_64-linux";
    nativeBuildInputs = [ pkgs.cargo ];
    buildPhase = ''
      cargo build --release
    '';
    installPhase = ''
      mkdir -p $out/bin
      cp target/release/rust-hello $out/bin/rust-hello
      chmod +x $out
    '';
}
 ```
 
# flakes

a new standard format for nix projects to declare all their outputs

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-22.05";

  outputs = {
    self,
    nixpkgs,
  }: let
    system = "x86_64-linux";
    pkgs = import nixpkgs {inherit system;};
  in {
    packages.${system}.default =
      pkgs.stdenv.mkDerivation
      {
        src = ./rust-hello;
        name = "rust-hello-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build --release
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/release/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
  };
}
```

The flake.nix file defines a Nix attribute set, with two top level attributes. 

The first of these is inputs, which defines all the dependencies this flake will import from. 

The second top level attribute is outputs, which is defined as a function returning an attribute set. 

It receives two arguments, self, which is the flake iself so you can refer to other outputs without resorting to rec,
and nixpkgs, which is the input the flake defined in the inputs attribute set. 

When the function is called, it gets the pkgs object by importing the nixpkgs expression. Inside flakes you also need to tell it which system to build nixpkgs for, so the flake passes it the x86_64-linux system field. 

This example flake defines a single output: packages.x86_64-linux.default.

A flake can have multiple packages defined in the one flake. 

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-22.05";

  outputs = {
    self,
    nixpkgs,
  }: let
    system = "x86_64-linux";
    pkgs = import nixpkgs {inherit system;};
  in {
    # The default package is the same as before
    packages.${system} = {
      default = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build --release
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/release/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
      # Now there's a new package
      debug = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-debug-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        buildPhase = ''
          cargo build
        '';
        installPhase = ''
          mkdir -p $out/bin
          cp target/debug/rust-hello $out/bin/rust-hello
          chmod +x $out
        '';
      };
    };
  };
}
```

As before, it's still possible to build the release package with a nix build. The newly added debug package can be built with nix build .#debug.

# Developer Environments

While packages are the most common type of item you'll find contained in flakes, another type of item is a *development shell*.

This is an environment that you can enter with the `nix develop` command

 By running just nix develop without specifying which shell is wanted, nix will put you in a bash shell with the environment from the default package.

However, sometimes you may wish to set up additional tools in a development environment, for example you may have scripts written in Python and want to have Python available as for a developer to use, yet you do not want to include Python as a dependency in your built package. 

You can customise the nix develop environment with the devShells attribute set in a flake. 

The helper function pkgs.mkShell is useful here.
This is an extended version of the mkDerivation function that has been used in previous examples, except this version is specialised for shells.

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
    in
    {
      devShells.x86_64-linux.default = pkgs.mkShell {
        packages = [
          # Made available on the CLI
          pkgs.cargo
          pkgs.rustc
          pkgs.python3
        ];
        RUST_LOG = 1; # Set as environment variable
      };

      # You could also define extra shells or packages here
    };
}
```
- Now if you run `nix develop` in the same directory as this flake, you'll be left at a bash shell with cargo, python3 and rustc available.


You could even define multiple shells. 

``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
      # A list of shell names and their Python versions
      pythonVersions = {
        python38 = pkgs.python38;
        python39 = pkgs.python39;
        python310 = pkgs.python310;
        default = pkgs.python310;
      };
      # A function to make a shell with a python version
      makePythonShell = shellName: pythonPackage: pkgs.mkShell {
        # You could add extra packages you need here too
        packages = [ pythonPackage ]; 
        # You can also add commands that run on shell startup with shellHook
        shellHook = ''
          echo "Now entering ${shellName} environment."
        '';
      };
    in
    {
      # mapAttrs runs the given function (makePythonShell) against every value
      # in the attribute set (pythonVersions) and returns a new set
      devShells.x86_64-linux = builtins.mapAttrs makePythonShell pythonVersions;
    };
}
```
- Now if you run the command nix develop .#python38, you will end up in a shell that contains Python 3.8,

You can also inspect all items that are available in the flake with the command nix flake show:


if you want to use another shell like zsh or fish
``` nix
{
  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";

  outputs = { self, nixpkgs }:
    let
      pkgs = import nixpkgs { system = "x86_64-linux"; };
    in
    {
      devShells.x86_64-linux.default = pkgs.mkShell {
        packages = [
          pkgs.fish
        ];
        # Note that `shellHook` still uses bash syntax.
        # This starts fish, then exists the bash shell when fish exits.
        shellHook = ''
          fish && exit
        '';
      };
    };
}
```

# Runnable Flakes

In the last two parts, I covered using flakes for two different types of output: packages and developer environments.

This time I'll cover a third type of output - runnable commands.


specify name of program to run if when run `nix run .#debug`
``` nix
# Rest of flake omitted
{
    debug = pkgs.stdenv.mkDerivation {
        src = ./rust-hello;
        name = "rust-hello-debug-1.0";
        inherit system;
        nativeBuildInputs = [pkgs.cargo];
        meta.mainProgram = "rust-hello";
        buildPhase = ''
            cargo build
        '';
        installPhase = ''
            mkdir -p $out/bin
            cp target/debug/rust-hello $out/bin/rust-hello
            chmod +x $out
        '';
    };
}
```


meta.mainProgram is a great option when you have a package to run which is named differently to its binary, but in some situations you may want even more control over what happens. For example, you might want to add a run configuration to run a static web server for dev purposes.

To add a run configuration not tied to a built package, you can use the apps key of a flake. 
This takes two keys, type, and program.
type must be set to app 
program is set to the path to a binary to execute.


``` nix
{
    apps.${system}.default = let
      serv = pkgs.writeShellApplication {
        # Our shell script name is serve
        # so it is available at $out/bin/serve
        name = "serve";
        # Caddy is a web server with a convenient CLI interface
        runtimeInputs = [pkgs.caddy];
        text = ''
          # Serve the current directory on port 8090
          caddy file-server --listen :8090 --root .
        '';
      };
    in {
      type = "app";
      # Using a derivation in here gets replaced
      # with the path to the built output
      program = "${serv}/bin/serve";
    };
}
```

From here you can run `nix run`

Dockerfiles help you build the software, but they don't really help you run or operate the software. 
Nix flakes is more akin to docker-compose, they help you compose packages written in Nix to run across machines.

you can make a flake from a template

``` shell
mkdir ~/tmp/go-demo
cd ~/tmp/go-demo
nix flake new -t templates#go-hello .
git init && git add .
```

``` nix
{
  description = "A simple Go package";

  # Nixpkgs / NixOS version to use.
  inputs.nixpkgs.url = "nixpkgs/nixos-21.11";

  outputs = { self, nixpkgs }:
    let

      # Generate a user-friendly version number.
      version = builtins.substring 0 8 self.lastModifiedDate;

      # System types to support.
      supportedSystems = [ "x86_64-linux" "x86_64-darwin" "aarch64-linux" "aarch64-darwin" ];

      # Helper function to generate an attrset '{ x86_64-linux = f "x86_64-linux"; ... }'.
      forAllSystems = nixpkgs.lib.genAttrs supportedSystems;

      # Nixpkgs instantiated for supported system types.
      nixpkgsFor = forAllSystems (system: import nixpkgs { inherit system; });

    in
    {

      # Provide some binary packages for selected system types.
      packages = forAllSystems (system:
        let
          pkgs = nixpkgsFor.${system};
        in
        {
          # The default package for 'nix build'. This makes sense if the
          # flake provides only one package or there is a clear "main"
          # package.
          default = pkgs.buildGoModule {
            pname = "go-hello";
            inherit version;
            # In 'nix develop', we don't need a copy of the source tree
            # in the Nix store.
            src = ./.;

            # This hash locks the dependencies of this package. It is
            # necessary because of how Go requires network access to resolve
            # VCS.  See https://www.tweag.io/blog/2021-03-04-gomod2nix/ for
            # details. Normally one can build with a fake sha256 and rely on native Go
            # mechanisms to tell you what the hash should be or determine what
            # it should be "out-of-band" with other tooling (eg. gomod2nix).
            # To begin with it is recommended to set this, but one must
            # remeber to bump this hash when your dependencies change.
            #vendorSha256 = pkgs.lib.fakeSha256;

            vendorSha256 = "sha256-pQpattmS9VmO3ZIQUFn66az8GSmB4IvYhTTCFn6SUmo=";
          };
        });
    };
}
```

`$ nix build`
then

```
$ ./result/bin/go-hello
Hello Nix!
```

you can also run the default package with this command

``` shell
$ nix build .#default
```


# exposing packages as application
Additionally, you can expose a package as an application. 
This allows you to simplify that above nix build and ./result/bin/go-hello cycle into a single nix run command.

Open flake.nix in your favorite editor and let's configure go-hello to be the default app:

``` nix
# below packages

apps = forAllSystems (system: {
  default = {
      type = "app";
      program = "${self.packages.${system}.default}/bin/go-hello";
  };
});
```


``` shell
 nix run
Hello Nix!
```

One of Nix's superpowers is the ability to declaratively manage the development environment for a project so that you can be sure that everyone working on the project is using the same tools.

Flakes has the ability to specify this using the devShells flake output.

``` nix
devShells = forAllSystems (system:
  let pkgs = nixpkgsFor.${system};
  in {
    default = pkgs.mkShell {
      buildInputs = with pkgs; [ go gopls gotools go-tools ];
    };
  });
```

# external dependencies

Flake inputs let you add external dependencies to a project. 

``` nix
# Nixpkgs / NixOS version to use.
inputs.nixpkgs.url = "nixpkgs/nixos-21.11";
```

we can upgrade to unstable

``` nix
# Nixpkgs / NixOS version to use.
inputs.nixpkgs.url = "nixpkgs/nixos-unstable";
```

This also lets you pull in other Nix flakes projects,

``` nix
inputs.xess.url = "github:Xe/Xess";
inputs.xess.inputs.nixpkgs.follows = "nixpkgs";
```
- . By making Xess' nixpkgs input follows our own one, we are saying "I understand this may be incompatible, but please use this version of nixpkgs instead".

Or anything you want! A useful library to pull in is flake-utils,




# building a rust service with Nix

a flake file is just a regular nix file.  It needs to evaluate to a set with *inputs* and *outputs*


One thing a flake can have as an output is... an executable!

``` nix
# in flake.nix
{
  inputs = {
    # this is equivalent to `nixpkgs = { url = "..."; };`
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = inputs: {
    packages."x86_64-linux".default = derivation {
      name = "simple";
      builder = "${inputs.nixpkgs.legacyPackages."x86_64-linux".bash}/bin/bash";
      args = [ "-c" "echo foo > $out" ];
      src = ./.;
      system = "x86_64-linux";
    };
  };
}
```


`nix flake show`
- show outputs

we can destructue the the arguments of outputs:

``` nix
# in flake.nix
{
  inputs = {
    # this is equivalent to `nixpkgs = { url = "..."; };`
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  # now a set üëá
  outputs = { self, nixpkgs }: {
    packages."x86_64-linux".default = derivation {
      name = "simple";
      # was `inputs.nixpkgs`, now just:
      builder = "${nixpkgs.legacyPackages."x86_64-linux".bash}/bin/bash";
      args = [ "-c" "echo foo > $out" ];
      src = ./.;
      system = "x86_64-linux";
    };
  };
}
```

we can alos use let to make things tidyer

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = { self, nixpkgs }:
    let
      # define system once
      system = "x86_64-linux";
      # use it here, and bind platform-specific packages to `pkgs`
      pkgs = nixpkgs.legacyPackages.${system};
    in
    {
      # we can use `${system}` here!
      packages.${system}.default = derivation {
        name = "simple";
        # with `with`, we can just do `bash`
        builder = with pkgs; "${bash}/bin/bash";
        args = [ "-c" "echo foo > $out" ];
        src = ./.;
        system = system;
      };
    };
}
```


make it nicer

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
  };
  outputs = { self, nixpkgs }:
    let
      system = "x86_64-linux";
      name = "simple";
      src = ./.;
      pkgs = nixpkgs.legacyPackages.${system};
    in
    {
      packages.${system}.default = derivation {
        inherit system name src;
        builder = with pkgs; "${bash}/bin/bash";
        args = [ "-c" "echo foo > $out" ];
      };
    };
}
```

for a bunch of other targets

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    # we have a new input!
    flake-utils.url = "github:numtide/flake-utils";
  };
  #      it's destructured here
  outputs = { self, nixpkgs, flake-utils }:
    # calling a function from `flake-utils` that takes a lambda
    # that takes the system we're targetting
    flake-utils.lib.eachDefaultSystem (system:
      let
        # no need to define `system` anymore
        name = "simple";
        src = ./.;
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        # `eachDefaultSystem` transforms the input, our output set
        # now simply has `packages.default` which gets turned into
        # `packages.${system}.default` (for each system)
        packages.default = derivation {
          inherit system name src;
          builder = with pkgs; "${bash}/bin/bash";
          args = [ "-c" "echo foo > $out" ];
        };
      }
    );
}
```

another example
``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };
  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        name = "simple";
        src = ./.;
        pkgs = nixpkgs.legacyPackages.${system};
      in
      {
        packages.default = derivation {
          inherit system name src;
          builder = with pkgs; "${bash}/bin/bash";
          args = [ "-c" "echo foo > $out" ];
        };
        packages.shaka-packager =
          let
            version = "2.6.1";
            inherit (pkgs) stdenv lib;
          in
          stdenv.mkDerivation
            {
              name = "shaka-packager-${version}";

              # https://nixos.wiki/wiki/Packaging/Binaries
              src = pkgs.fetchurl {
                url =
                  "https://github.com/shaka-project/shaka-packager/releases/download/v${version}/packager-linux-x64";
                sha256 = "sha256-MoMX6PEtvPmloXJwRpnC2lHlT+tozsV4dmbCqweyyI0=";
              };

              dontUnpack = true;
              sourceRoot = ".";

              installPhase = ''
                install -m755 -D $src $out/bin/shaka-packager
              '';

              meta = with nixpkgs.lib; {
                homepage = "https://shaka-project.github.io/shaka-packager/html/";
                description =
                  "Media packaging framework for VOD and Live DASH and HLS applications";
                platforms = platforms.linux;
              };
            };
      }
    );
}
```


not for all environments

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
  };
  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem
      (system:
        let
          name = "simple";
          src = ./.;
          pkgs = nixpkgs.legacyPackages.${system};
        in
        {
          packages = {
            default = derivation {
              inherit system name src;
              builder = with pkgs; "${bash}/bin/bash";
              args = [ "-c" "echo foo > $out" ];
            };
          } // (if system == "x86_64-linux" then {
            shaka-packager =
              let
                version = "2.6.1";
                pkgs = nixpkgs.legacyPackages.x86_64-linux;
                inherit (pkgs) stdenv lib;
              in
              stdenv.mkDerivation
                {
                  name = "shaka-packager-${version}";

                  # https://nixos.wiki/wiki/Packaging/Binaries
                  src = pkgs.fetchurl {
                    url =
                      "https://github.com/shaka-project/shaka-packager/releases/download/v${version}/packager-linux-x64";
                    sha256 = "sha256-MoMX6PEtvPmloXJwRpnC2lHlT+tozsV4dmbCqweyyI0=";
                  };

                  dontUnpack = true;
                  sourceRoot = ".";

                  installPhase = ''
                    install -m755 -D $src $out/bin/shaka-packager
                  '';

                  meta = with nixpkgs.lib; {
                    homepage = "https://shaka-project.github.io/shaka-packager/html/";
                    description =
                      "Media packaging framework for VOD and Live DASH and HLS applications";
                    platforms = platforms.linux;
                  };
                };
          } else { });
        }
      );
}
```


# overlays.
- the result of `import <nixpkgs>` is a function that can be called with a set

- overlay provide packages that aren't in nixpkgs by default

``` nix
# in flake.nix
{
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay.url = "github:oxalica/rust-overlay";
  };
  outputs = { self, nixpkgs, flake-utils, rust-overlay }:
    flake-utils.lib.eachDefaultSystem
      (system:
        let
          overlays = [ (import rust-overlay) ];
          pkgs = import nixpkgs {
            inherit system overlays;
          };
        in
        with pkgs;
        {
          devShells.default = mkShell {
            buildInputs = [ rust-bin.stable.latest.default ];
          };
        }
      );
}
```

so that we don't import nixpkgs and flake-utils twice
gets rid of duplicates
``` nix
# in flake.nix (only inputs shown)
  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        flake-utils.follows = "flake-utils";
      };
    };
  };
```
- avoid rebuild the world situations


# Nix Flakes

Flakes allow to define inputs (you can think of them as dependencies) and outputs of packages in a declarative way.

`nix flake new` can be used to create a new flake, it also supports templates!

`nix flake new . -t templates#rust`

There are 3 top level attributes and various sub-attributes:

``` nix
{
	description = "I am an optional description";
	
	# inputs contains all the dependencies of the flake
	inputs = {
		nixpkgs.url = "github:NixOs/nixpkgs" # this is set by default
		flake-utils.url = "github:numtide/flake-utils" # this is another flake
	};
	
	# outputs is a function that has the inputs are passed as parameters
	outputs = { self, nixpkgs, flake-utils }:

		packages = ... # packages exposed by this flake, used by nix build
		defaultPackage = ... # package called when nix build has no arguments
		
		apps = ... # apps exposed by this flake, used by nix run
		defaultApp = ... # app called when nix run has no arguments
		
		devShell = ... # this is the definition of the nix-shell
		
    ... # there's much more, see the NixOS wiki for details
	
	}

}
```


Here‚Äôs an example of a basic development shell with ripgrep:

``` nix
{
  description = "A basic devShell";

  outputs = { self, nixpkgs }:
    let pkgs = nixpkgs.legacyPackages.x86_64-linux;

    in {
      devShell.x86_64-linux = pkgs.mkShell {
        buildInputs = with pkgs; [ ripgrep ];

        shellHook = ''
          echo "shell with ripgrep"
        '';
      };

    };
}
```

To avoid having to repeat our declaration for each architecture we intend to support we can use eachDefaultSystem from flake-utils .

``` nix
{
  description = "A basic devShell using flake-utils each";

  inputs.flake-utils.url = "github:numtide/flake-utils";

  outputs = { self, nixpkgs, flake-utils }:
      flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system}; in
      rec {
        devShell = pkgs.mkShell {
          buildInputs = with pkgs; [ ripgrep ];

          shellHook = ''
            echo "shell with ripgrep"
          '';
        };
      }
    );
}
```

# Pratical Nix Flakes

Briefly speaking, Nix is a package manager and a build system

There is a vast repository of packages for Nix called nixpkgs, 
and a GNU/Linux distribution that extends the ideas of Nix to the OS level called NixOS.

Nix building instructions are called ‚Äúderivations‚Äù and are written in the Nix programming language
-  they can then be deterministically ‚Äúrealised‚Äù 
- Derivations can only depend on a pre-defined set of inputs, so they are somewhat reproducible

Flakes are self-contained units that have inputs (dependencies) and outputs (packages, deployment instructions, Nix functions for use in other flakes). 

 Flakes have great reproducibility because they are only allowed to depend on their inputs and they pin the exact versions of said inputs in a lockfile.

test hello
`nix shell github:nixos/nixpkgs/nixpkgs-unstable#hello`

Nix evaluates a derivation from the expression, hashes its contents, and queries all the caches it knows to see if someone has the derivation with this hash cached

all Nix derivations have ‚Äústore paths‚Äù (paths located in /nix/store)

 it has the ability to provide a build environment for its derivations.
 
 Nix implements stateful ‚Äúprofiles‚Äù to allow users to ‚Äúpermanently‚Äù install stuff.
 
 ``` shell
 nix profile install nixpkgs#hello
nix profile list
nix profile update hello
nix profile remove hello
 ```

`nix flake show`
This command takes a flake URI and prints all the outputs of the flake

`nix flake clone` 
will clone the flake source to a local directory, similar to git clone

# nix object

``` nix
{
  hello = "world";
  foo = "bar";
}
```

``` nix
{
  foo.bar = "baz";
}
```

``` nix
{
  foo = { bar = "baz"; };
}
```

# let

``` nix
let
  my_attrset = { foo = "bar"; };
in my_attrset.foo
```

# function

``` nix
{ a, b }: a + b
```

``` nix
let
  f = { a, b }: a + b;
in f { a = 10; b = 20; }
```

function with multiple arguments, use currying
``` nix
let
  f = a: b: a + b;
in f 10 20
```

# basic flake structure 

A Nix flake is a directory that contains a flake.nix file. That file must contain an attribute set with one required attribute ‚Äì outputs ‚Äì and optionally description and inputs.

outputs is a function that takes an attribute set of inputs

most simple example

``` nix
{
  outputs = { self }: { };
}
```

``` nix
{
  outputs = { self }: {
    foo = "bar";
  };
}
```

` nix eval .#foo`

give it some inputs
``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: { };
}
```


While the attribute set that outputs returns may contain arbitrary attributes, some standard outputs are understood by various nix utilities

for example packages

``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.hello = /* something here */;
  };
}
```
- all flake outputs that have anything to do with packages must specify the platform explicitly in some way


``` nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
  };

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;
  };
}
```

`nix build .#hello`
and then
`nix run .#hello`

Another thing we can add is a ‚Äúdevelopment‚Äù shell containing some utilities that might be useful when working on our flake.

there is a special output for such development shells, called devShell. 


here is also a function for building such shells in nixpkg

``` nix
{
  inputs = { nixpkgs.url = "github:nixos/nixpkgs"; };

  outputs = { self, nixpkgs }:
    let pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in {
      packages.x86_64-linux.hello = pkgs.hello;

      devShell.x86_64-linux =
        pkgs.mkShell { buildInputs = [ self.packages.x86_64-linux.hello pkgs.cowsay ]; };
   };
}
```

run it in zsh
`nix shell -c zsh`

# flake-utils

```nix
{
  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in {
        packages.hello = pkgs.hello;

        devShell = pkgs.mkShell { buildInputs = [ pkgs.hello pkgs.cowsay ]; };
      });
}
```


# templates 

`nix flake init -t`

`nix flake init -t github:serokell/templates#haskell-cabal2nix`

``` nix
{
  description = "My haskell application";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        haskellPackages = pkgs.haskellPackages;

        jailbreakUnbreak = pkg:
          pkgs.haskell.lib.doJailbreak (pkg.overrideAttrs (_: { meta = { }; }));

        packageName = throw "put your package name here!";
      in {
        packages.${packageName} = # (ref:haskell-package-def)
          haskellPackages.callCabal2nix packageName self rec {
            # Dependency overrides go here
          };

        defaultPackage = self.packages.${system}.${packageName};

        devShell = pkgs.mkShell {
          buildInputs = with haskellPackages; [
            haskell-language-server
            ghcid
            cabal-install
          ];
          inputsFrom = builtins.attrValues self.packages.${system};
        };
      });
}
```

python

``` nix
{
  description = "My Python application";

  inputs = {
    nixpkgs.url = "github:NixOS/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.${system};

        customOverrides = self: super: {
          # Overrides go here
        };

        app = pkgs.poetry2nix.mkPoetryApplication {
          projectDir = ./.;
          overrides =
            [ pkgs.poetry2nix.defaultPoetryOverrides customOverrides ];
        };

        packageName = throw "put your package name here";
      in {
        packages.${packageName} = app;

        # set package as default
        defaultPackage = self.packages.${system}.${packageName};

        # provide package as imput
        devShell = pkgs.mkShell {
          buildInputs = with pkgs; [ poetry ];
          inputsFrom = builtins.attrValues self.packages.${system};
        };
      });
}
```

# nix series

There's no containerization going on (no user namespaces), no virtual machines, no nothing: it's just plain old executables, that only refer to things inside the /nix/store.

 what's that long hash about it? It's derived from the inputs, which means, paths either never clash (because they have different inputs), 
 
# home-manager

manage your home configuration
- packages
- dotfiles???
- environment variables
- services

it uses *nix langage* and *nix package manager* 

standalone installation
- just a program

first install nix

setup
`nix run home-manager -- init --switch .`
- generates two file *home.nix* and *flake.nix*

activate
`home-manger switch --flake .#nixhero-home`

`home-manager generation`
- show generations of your config

`nix-collect-garbage -d`
- remove unused packages

setup a program

``` nix
programs.git = {
  enable = true;
  userName = "as;lfj";
  userEmail = "...";
}
```

1. create a directory for home-manger
`mkdir wsl-home`

2. setup nix shell with home-manger 
`nix shell nixpkgs#home-manager`
`home-manager --version`

3. initiate home manger
`home-manger init .`
- this will create two file
*flake.nix*
*home.nix*

4. use the config
`home-manger switch --flake .#<target>`

5. setup packages
open home.nix

```nix
home.packages = [
  pkgs.hello
]
```

```nix
programs.bash.enable = true
porgrams.neovim.enable = true
```

you can use home-manger as a package
and setup through nix shell


create directory for home manger
`mkdir home-manger1`

setup home manger
`nix run home-manger -- init --switch .`

you can now run home-manger
`home-manger --version`

two files were created in your directory
- flake.nix
- home.nix


Flake.nix
```nix
homConfigureations."homemanger" = home-manager.lib.homeManagerConfiguration {
  inherit pkgs;
  modules = [ ./home.nix ];
}
```

activate your configuration
```nix
home-manger switch --flake .#homemangager
```
- activate configuration
- specifies which configuration
- .#homemanager
  + use flake in current directory and profile .#hommanager


home.nix
```nix
{ 
	home.packages = [
		# pkgs.hello
	]
}
```

this creates a file
```nix
{
	home.file.<path>.text = "";
}
```
- this is a symlink to /nix/store/...

configure your own bash
'''nix
{
	programs.fzf.enable = true;
	programs.bash.enable = true;
}
'''

setup services
```nix
service.<service>.enable = true
```

geneartion
`home-manager generation`

remove unused generations
`nix-collect-garbage -d`


`nix shell nixpkgs#home-manager`
`home-manger --version`
`home-manger init .`
`home-manager switch --flake .#<target>`

```nix
home.package = [
  pkgs.neofetch
]

programs.bash.enable = true
```
- allow home-manger to configure bash

`home-manger switch --flake .#<name> -b backup.bash.file`
